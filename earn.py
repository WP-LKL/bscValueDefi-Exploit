import json
import requests
import time
import base64
import os
import subprocess
import winsound
from utils import deObfuscate as d

with open('config.json', 'r') as f:
    config = json.load(f)

# VARIABLE                            # TYPE (DEFAULT) : <DESCRIPTION>. 
MYADDRESS    = d(config["MYADDRESS"]) # STR  (None)    : Base64 encoded Public eth/bsc address.
APIKEY       = d(config["APIKEY"])    # STR  (None)    : Base64 encoded bscScan.com API key.
RISK         = config["RISK"]         # FL   (1.05)    : Risk profile of missing user-compound.
SAFEBASELINE = config["SAFEBASELINE"] # UINT (1e17)    : Initial assets - deflationary.
FARMBASELINE = config["FARMBASELINE"] # UINT (1e17)    : Initial assets - inflationary.
GASTHRESHOLD = config["GASTHRESHOLD"] # UINT (3e15)    : Before swapping/harboring in vSafe.
MINTX        = config["MINTX"]        # UINT (1e5)     : Minimum transaction amount.
BUFFER       = config["BUFFER"]       # UINT (160)     : Minimum earn() block distance.
AUTOCOMPLIM  = config["AUTOCOMPLIM"]  # UINT (1e14)    : Not implemented.
AUTOCOMPOUND = config["AUTOCOMPOUND"] # Bool (false)   : Not implemented.
VERBOSE      = config["VERBOSE"]      # Bool (true)    : Verbosity of prints.
ALARM        = config["ALARM"]        # Bool (false)   : Artifact. 4 second alarm at script termination. (IFTTT)
DEBUG        = config["DEBUG"]        # Bool (false)   : Extra verbosity.
MAKER        = config["MAKER"]        # Bool (true)    : Force earn based on estBlock().

""" Token addresses """
VSAFETOKEN   = "0x925d67e6b2e86380833e7c950cccd3748d38baea" 
LPTOKEN      = "0x8dd39f0a49160cda5ef1e2a2fa7396eec7da8267"
BSWAPTOKEN   = "0x4f0ed527e8a95ecaa132af214dfd41f30b361600"

dir = "bsc/"  # Directory for scripts interacting with BlockChain

class Swapper():
    def __init__(self, startBlock=5188000, location="farm"):
        self.startBlock = startBlock # API Limit
        self.contract = "0xf08253ebb55c5da33d637ad201a00760776f1d3b"
        self.txEndpoint = f"https://api.bscscan.com/api?module=account&action=txlist&address={self.contract}&startblock={self.startBlock}%20&endblock=99999999&sort=asc&apikey={APIKEY}" 
        self.lastBlock = None
        self.location = location
        
        results = getResults(self.txEndpoint)
        self.startBlock = results[-5]["blockNumber"] 
        self.txEndpoint = f"https://api.bscscan.com/api?module=account&action=txlist&address={self.contract}&startblock={self.startBlock}%20&endblock=99999999&sort=asc&apikey={APIKEY}" 

    def estNextEarn(self):
        results = getResults(self.txEndpoint)
        if len(results) > 5:
            self.startBlock = results[-4]["blockNumber"]
            self.txEndpoint = f"https://api.bscscan.com/api?module=account&action=txlist&address={self.contract}&startblock={self.startBlock}%20&endblock=99999999&sort=asc&apikey={APIKEY}" 

        dist = 0
        prior = results[0]["blockNumber"] 
        for x in (results[1:]):
            if DEBUG: print(f"distance: {dist}")
            dist += int(x["blockNumber"]) - int(prior)
            prior = x["blockNumber"]
            
        avg = dist/(len(results)-1)
        if DEBUG: print(f"avg: {avg}")
        self.lastBlock = int(results[-1]["blockNumber"])
        if DEBUG: print(f"last block: {self.lastBlock}")
        estBlock = int(self.lastBlock+avg*RISK)
        return min(estBlock, self.lastBlock+550)


def debugDump(s):
    safeBalance = tokenBalance(VSAFETOKEN)
    walletBalance = tokenBalance(LPTOKEN)
    print(f"Balance: {safeBalance} VSAFETOKEN and {walletBalance} LPTOKEN. At {swapper.location}.")
    print(time.strftime("%H:%M:%S", time.localtime()))
    print(s)

def getCurrentBlock() -> int:
    response = requests.get(f"https://api.bscscan.com/api?module=proxy&action=eth_blockNumber&apikey={APIKEY}")
    response = json.loads(response.text)
    result = int(response["result"], 16)
    return result
        
def getResults(txEndpoint):
    for attempt in range(30):
        try:
            response = requests.get(txEndpoint, headers={'Cache-Control': 'no-cache', "Pragma": "no-cache"})
            response = json.loads(response.text)
            return response["result"] 
        except:
            time.sleep(2)
            continue

def callEarn():
    """ Contract recalculate share price. """
    method = "d389800f"
    txData = f"0x{method}"
    assert len(txData)==10
    return subprocess.run(f"npx ts-node {dir}callEarn.ts --txData={txData}", shell=True, stdout=subprocess.PIPE, check=True)

def addBNB(amount):
    """ Swap BSWAPTOKEN for BNB. """
    raise NotImplementedError

def checkTx():
    """ Check Transaction Status. """
    raise NotImplementedError

def compound():
    """ Reinvest by swapping 50% of farm yields for BNB. """
    raise NotImplementedError
    bswapBalance = tokenBalance(BSWAPTOKEN)
    addBNB(bswapBalance/2)

def depositSafe(amount):
    assert amount > MINTX
    amount = str(hex(amount))[2:]
    padding = "0"*(64-len(amount))
    method = "e2bbb158"
    minimum = "0"*64
    txData = f"0x{method}{padding}{amount}{minimum}"
    assert len(txData)==138
    return subprocess.run(f"npx ts-node {dir}depositSafe.ts --txData={txData}", shell=True, stdout=subprocess.PIPE, check=True)

def depositFarm(amount):
    assert amount > MINTX
    amount = str(hex(amount))[2:]
    padding = "0"*(64-len(amount))
    method = "e2bbb158"
    pid = "0"*64
    txData = f"0x{method}{padding}{pid}{amount}"
    assert len(txData)==138
    return subprocess.run(f"npx ts-node {dir}depositFarm.ts --txData={txData}", shell=True, stdout=subprocess.PIPE, check=True)

def withdrawSafe(amount):
    assert amount > MINTX
    amount = str(hex(amount))[2:]
    padding = "0"*(64-len(amount))
    method = "441a3e70"
    minimum = "0"*64
    txData = f"0x{method}{padding}{amount}{minimum}"
    assert len(txData)==138
    return subprocess.run(f"npx ts-node {dir}withdrawSafe.ts --txData={txData}", shell=True, stdout=subprocess.PIPE, check=True)

def withdrawFarm(amount):
    assert amount > MINTX
    amount = str(hex(amount))[2:]
    padding = "0"*(64-len(amount))
    method = "441a3e70"
    pid = "0"*64
    txData = f"0x{method}{padding}{pid}{amount}"
    assert len(txData)==138
    return subprocess.run(f"npx ts-node {dir}withdrawFarm.ts --txData={txData}", shell=True, stdout=subprocess.PIPE, check=True)

def bnbBalance():
    txEndpoint = f"https://api.bscscan.com/api?module=account&action=balance&address={MYADDRESS}&tag=latest&apikey={APIKEY}" 
    results = getResults(txEndpoint)
    return int(results)

def tokenBalance(tokenAddress):
    txEndpoint = f"https://api.bscscan.com/api?module=account&action=tokenbalance&contractaddress={tokenAddress}&address={MYADDRESS}&tag=latest&apikey={APIKEY}" 
    results = getResults(txEndpoint)
    return int(results)

def verifyDeposit(tokenAddress):
    if tokenAddress == LPTOKEN: baseline = FARMBASELINE
    for _ in range(60):
        balance = tokenBalance(tokenAddress)
        if balance < 10000:
            if VERBOSE : print(f"Verified deposit for LPTOKEN. Balance: {balance}")
            return True

        time.sleep(2)
    if VERBOSE: print(f"Deposit not registered for LPTOKEN. Balance: {balance}.")
    return False

def verifyBalance(tokenAddress):
    if tokenAddress == VSAFETOKEN: 
        baseline = SAFEBASELINE
        token = "vSafeToken"
    if tokenAddress == LPTOKEN: 
        baseline = FARMBASELINE
        token = "LP-Token"
    for _ in range(60):
        balance = tokenBalance(tokenAddress)
        if balance >= baseline-100:
            if VERBOSE : print(f"{token} balance: {balance}")
            return balance

        time.sleep(1)
    if VERBOSE: print(f"Insufficient {token} balance: {balance} vs {baseline}")
    return False
    
run = True

if tokenBalance(LPTOKEN) > FARMBASELINE:
    location = "wallet"
elif tokenBalance(VSAFETOKEN) > SAFEBASELINE:
    location = "safe"
else:
    location = "farm"
    print("WARNING: Value within vFarm cannot be inferred. Consider starting in vSafe or Wallet.")

if VERBOSE: print(f"Initial location registered as: {location}")

swapper = Swapper(location=location)
estBlock = swapper.estNextEarn()

swaps = 0
missed = 0
swapped = False
excessBlocks = 0
lastSwap = estBlock
if MAKER == True:
    if swapper.location == "safe":
        callEarn()
        pass
# START IN FARM
while run:
    time.sleep(5)   
    estBlock = swapper.estNextEarn()
    currentBlock = getCurrentBlock()
    balanceBNB = bnbBalance()
    if VERBOSE : print(f"({swapper.location}) Estimated block: {estBlock}. Current block: {currentBlock}. BNB balance: {balanceBNB}. Swaps: {swaps}. missed: {missed}. Excess blocks: {excessBlocks}.")
    
    if swapped == False and estBlock != lastSwap and lastSwap > currentBlock:
        print(f"Miss of {lastSwap-currentBlock}.")
        missed += lastSwap-currentBlock

    elif estBlock != lastSwap and lastSwap < currentBlock:
        print(f"Excess of {currentBlock-lastSwap}.")
        excessBlocks += currentBlock-lastSwap
        swapped = True
    else:
        swapped = False
    lastSwap = estBlock

    if (swapper.location != "safe" and currentBlock > estBlock) or (swapper.location == "wallet"):
        if swapper.location == "farm": 
            withdrawFarm(FARMBASELINE)
        if verifyBalance(LPTOKEN) == False:
            debugDump(f"ERROR: Couldnt Withdraw {FARMBASELINE} LP-Token from vFarm")
            # Stop or re-attempt
            run = False
            break
        else:
            swapper.location = "wallet"
            if VERBOSE : print("wallet")
            
        depositSafe(tokenBalance(LPTOKEN))
        if verifyBalance(VSAFETOKEN) == False:
            debugDump(f"ERROR: Couldn't verify balance")
            # Stop or re-attempt
            run = False
            break
        else:
            swapper.location = "safe"
            if VERBOSE : print("safe")
            swaps += 1
        
        if MAKER == True: 
            callEarn()

    if (swapper.location != "farm" and currentBlock+BUFFER < estBlock):
        if swapper.location == "safe": 
            withdrawSafe(tokenBalance(VSAFETOKEN))
        if verifyBalance(LPTOKEN) == False:
            debugDump(f"ERROR: Couldn't Withdraw {tokenBalance(VSAFETOKEN)} from vSafe")
            # Stop or re-attempt
            run = False
            break
        else:
            FARMBASELINE = tokenBalance(LPTOKEN)
            swapper.location = "wallet"
            if VERBOSE : print("wallet")

        depositFarm(tokenBalance(LPTOKEN))
        if verifyDeposit(LPTOKEN) == False:
            # Stop or re-attempt
            debugDump("ERROR: Couldn't verify deposit into vFarm")
            run = False
            break
        else:
            swapper.location = "farm"
            if VERBOSE : print("farm")
            swaps += 1
    
    # TODO: Auto compound functionality
    if AUTOCOMPOUND:
        if AUTOCOMPLIM < tokenBalance(BSWAPTOKEN):
            pass

    # TODO: addGas(): Swap vBSwap for BNB 
    # Gas threshold -> Harbor assets in vSafe
    if balanceBNB < GASTHRESHOLD: 
        print("WARNING: low BNB balance")
        if swapper.location == "farm":
            withdrawFarm(FARMBASELINE)
            if verifyBalance(LPTOKEN) == False:
                debugDump(f"Couldnt Withdraw {FARMBASELINE} LP-Token from vFarm")
                # Stop or re-attempt
                run = False
                break
            else:
                swapper.location = "wallet"
                if VERBOSE : print("wallet")
                
            depositSafe(tokenBalance(LPTOKEN))
            if verifyBalance(VSAFETOKEN) == False:
                debugDump("Couldn't verify deposit of LP-Token")
                # Stop or re-attempt
                run = False
                break
            else:
                swapper.location = "safe"
                if VERBOSE : print("safe")
                swaps += 1

        run = False
        break

if swapper.location != "safe" and False:
    print("ERROR -> RETURNING TO SAFE")
    withdrawFarm(FARMBASELINE)
    if verifyBalance(LPTOKEN) == False:
        debugDump("Couldnt Withdraw from vFarm")
        # Stop or re-attempt
        run = False
    else:
        swapper.location = "wallet"
        if VERBOSE : print("wallet")
        
    depositSafe(tokenBalance(LPTOKEN))
    if verifyBalance(VSAFETOKEN) == False:
        # Stop or re-attempt
        run = False
    else:
        swapper.location = "safe"
        if VERBOSE : print("safe")
        swaps += 1

if ALARM:
    duration = 4000  # milliseconds
    freq = 440  # Hz
    winsound.Beep(freq, duration)